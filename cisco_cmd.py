#!/usr/bin/env python3

from Exscript.util.interact import read_login
from Exscript.protocols import SSH2
from Exscript.util.file import get_accounts_from_file
from Exscript.util.file import Account
import sys, getopt, time, datetime, getpass, importlib, os, built_in_commands, argparse
from cryptography.fernet import Fernet
import time
from termcolor import cprint


date = datetime.datetime.now()
###Help Menu
#The nargs='?', is used to not have to enter data after or the action='store_false'. Can be used to adjust what appears on screen when not requiring <-l all> <-l> alone will work
#metavar='<custom_cmd>'
#https://docs.python.org/3/howto/argparse.html
single_quotes = " ' ' " 
parser = argparse.ArgumentParser(description='  View README for detailed help/examples \n\n  " " or %s REQUIRED when using spaces \n\n  -o NOT required to run a built-in command' % single_quotes,formatter_class=argparse.RawTextHelpFormatter)
# parser.add_argument("hosts", help='Name of file with targeted')
parser.add_argument("-c", "--cmd", dest='', help='Run a built-in command from array')
parser.add_argument("-o", "--option", dest='', help='Optional user input filter for the builtin commands')
parser.add_argument("-d", "--custom", dest='', help='Custom command generated by user')                    
parser.add_argument("-m", "--module", dest='', help='Run selected module from the available modules')
parser.add_argument("-l", "--list-modules", action="store_false", help='List the available modules') 
parser.add_argument("-b", "--list-builtin", action="store_false", help='List the available built-in commands from an array')
args = parser.parse_args()
###
   
#Count hosts in the hosts_file
def count_hosts(hosts):
   counter = 0
   for i in hosts:
      if i:
         counter += 1
   return counter

#Gets creds
def get_creds():
   # username = input("Username [%s]: " % os.getlogin())         #For Linux
   # username = input("Username: ")                                #For WSL 2 or without default username:
   # if len(username) == 0 :
   #     username = os.getlogin()
   # password = getpass.getpass()
   # #Date for logs
   # # print("\n",date, "\n")
   # account = Account(username, password)

   #Get creds from file
   cred_filename = 'creds/CredFile.ini'
   key_file = 'creds/key.key'
   key = ''
   with open('creds/key.key','r') as key_in:
       key = key_in.read().encode()

   f = Fernet(key)
   with open(cred_filename,'r') as cred_in:
      lines = cred_in.readlines()
      config = {}
      for line in lines:
         tuples = line.rstrip('\n').split('=',1)
         if tuples[0] in ('Username','Password'):
             config[tuples[0]] = tuples[1]
      
      username = config['Username']
      password = f.decrypt(config['Password'].encode()).decode()
      account = Account(username, password)
      # account = [Account(username, password)]
      
   return account

#Used to run the -c & -d (built-in, custom) commands
def one_command(myFile, command):
    creds = get_creds()
    results = open("/tmp/cisco_cmd_logs/results.txt", "a")
    results.write(str(date) + "\n")
    for host in myFile:
        conn = SSH2()                       
        conn.connect(host)
        conn.login(creds)
        conn.execute('terminal length 0')
        conn.execute(command)
        # print out connection response
        results.write(host + "\n" + conn.response + "\n")
        print(host)
        print(conn.response + "\n")


#Create list for multi command file [-m]
def get_exscript_hosts(myFile):
   mylst = ''
   print(mylst)
   for host in myFile:
      mylst += "ssh://" + host + " "
   return mylst

###Generates the command to use with the multi command [-m]
def multcmd_cmds(mod_run, myFile):
   creds = get_creds()
   cprint(f"\nNUMBER OF HOSTS YOU ARE TARGETING: {count_hosts(myFile)}", "green")
   cprint("Device Responses = /tmp/cisco_cmd_logs/", "green")
   cprint(f"Running Commands From Module : {mod_run}\n", "green")
   cprint("Targets:", "green")
   for i in myFile:
      cprint(i, "red")

   cprint("Waiting 3 seconds for user cancel", "green")
   time.sleep(3)

   results = open("/tmp/cisco_cmd_logs/results.txt", "a")
   results.write(str(date) + "\n")
   for host in myFile:
      try:
         conn = SSH2()                       
         conn.connect(host)
         conn.login(creds)

      except Exception as e:
         print(e)
      
      else:
         for i in open("modules/"+mod_run).read().splitlines():
            conn.execute(i)
            results.write(host + "\n" + conn.response + "\n")
            print(conn.response + "\n") # print out connection response

###Generates the command to show built-in commands [-b]
def built_in_cmds():
  shorthand = built_in_commands.my_dict.keys()
  for i in shorthand:
     print(i + " = " + built_in_commands.my_dict.get(i))

###Gets file with targets
def zebra():
   filename = input("File in hosts directory with targets [Default: hosts_file]: ") or "hosts_file"
   # filename = "hosts_file"  #for a script
   return open("hosts/" + filename).read().splitlines()            #Print # hosts in file
   
#command line arguements - gets the -c -o, etc options
def main(argv):
   command = ''
   option = ''
   try:
      opts, args = getopt.getopt(argv,"hi:c:d:o:bi:m:li:",["cmd=","custom=","option=","list-builtin","module=","list-modules"])        #hi, bi, li - the i is required if want print to console maybe? it is required though. : is required at end
   except getopt.GetoptError:
      sys.exit(2)
   for opt, arg in opts:
      if opt in ("-c", "--cmd"):
         command = str(built_in_commands.my_dict.get(arg))
      elif opt in ("-d", "--customcmd"):
         command = arg
      elif opt in ("-o", "--option"):
         option = " " + arg
      elif opt in ("-b", "--list-builtin"):
         built_in_cmds()
         sys.exit()
      elif opt in ("-m", "--module"):
         myFile = zebra()
         multcmd_cmds(arg, myFile)
         sys.exit()
      elif opt in ("-l", "--list-modules"):
         i=sorted(os.listdir("modules"))
         for x in i:
            print(x)
         sys.exit()
      else:
         assert False, "unhandled option"
      final_cmd = command + option

   myFile = zebra()
   print("\nYOU ARE ABOUT TO RUN THE COMMAND: ",final_cmd)
   print("\nNUMBER OF HOSTS YOU ARE TARGETING: ",count_hosts(myFile))
   print("\nCANCEL NOW IF THIS IS THE WRONG COMMAND/HOST NUMBER \n")
   print("Responses are appended to /tmp/cisco_cmd_logs/results.txt")
   return one_command(myFile,final_cmd)

#initializes the "main" function so it provides command line variables
if __name__ == "__main__":
   command = main(sys.argv[1:])
